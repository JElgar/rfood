

@unpublished{food,
  title = {Decomposition Without Regret},
  author = {Anonymous},
  year = {2022},
  note = {Unpublished paper}
}

@software{syn,
  author = {David Tolnay},
  title = {Syn},
  url = {https://docs.rs/syn/latest/syn/},
  version = {1.0.91},
  date = {2022-04-03},
}

@article{cook,
author = {Cook, William R.},
title = {On Understanding Data Abstraction, Revisited},
year = {2009},
issue_date = {October 2009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {44},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/1639949.1640133},
doi = {10.1145/1639949.1640133},
abstract = {In 1985 Luca Cardelli and Peter Wegner, my advisor, published an ACM Computing Surveys paper called "On understanding types, data abstraction, and polymorphism". Their work kicked off a flood of research on semantics and type theory for object-oriented programming, which continues to this day. Despite 25 years of research, there is still widespread confusion about the two forms of data abstraction, abstract data types and objects. This essay attempts to explain the differences and also why the differences matter.},
journal = {SIGPLAN Not.},
month = {oct},
pages = {557–572},
numpages = {16},
keywords = {ADT, object, class, abstract data type}
}


@inproceedings{10.1145/1640089.1640133,
author = {Cook, William R.},
title = {On Understanding Data Abstraction, Revisited},
year = {2009},
isbn = {9781605587660},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1640089.1640133},
doi = {10.1145/1640089.1640133},
abstract = {In 1985 Luca Cardelli and Peter Wegner, my advisor, published an ACM Computing Surveys paper called "On understanding types, data abstraction, and polymorphism". Their work kicked off a flood of research on semantics and type theory for object-oriented programming, which continues to this day. Despite 25 years of research, there is still widespread confusion about the two forms of data abstraction, abstract data types and objects. This essay attempts to explain the differences and also why the differences matter.},
booktitle = {Proceedings of the 24th ACM SIGPLAN Conference on Object Oriented Programming Systems Languages and Applications},
pages = {557–572},
numpages = {16},
keywords = {object, ADT, class, abstract data type},
location = {Orlando, Florida, USA},
series = {OOPSLA '09}
}



@misc{rustsafesystems,
  author        = "Ralf Jung and Jacques-Henri Jourdan and Robbert Krebbers and Derek Dreyer",
  title         = "Safe Systems Programming in Rust: The Promise and the Challenge",
  year          = "2021"
}

 @article{cook_palsberg_1989, title={A denotational semantics of inheritance and its correctness}, volume={24}, DOI={10.1145/74878.74922}, number={10}, journal={ACM SIGPLAN Notices}, author={Cook, W. and Palsberg, J.}, year={1989}, pages={433–443}} 
 
 @misc{fp-uok, url={https://www.cs.kent.ac.uk/pubs/2009/2874/content.pdf}} 
 
 @misc{tufts,
  author        = "John C. Heynolds",
  title         = "User-Defined Types and Procedural Data Structures as Complementary Approaches to Data Abstraction",
}

@misc{warburton, title={Object-oriented vs. functional programming - Holla.cz}, url={https://pepa.holla.cz/wp-content/uploads/2016/10/object-oriented-vs-functional-programming.pdf}, author={Warburton, Richard}} 

@misc{rustonomicon, title={The rustonomicon}, url={https://doc.rust-lang.org/nomicon/exotic-sizes.html}, journal={Exotically Sized Types - The Rustonomicon}}

@misc{hutton, title={The countdown problem}, url={https://www.cs.nott.ac.uk/~pszgmh/countdown.pdf}, author={Hutton, Graham}} 

@misc{oopdesign, title={How to design classes - felleisen}, url={https://felleisen.org/matthias/HtDC/htdc.pdf}, author={Felleisen, Matthias and Flatt, Matthew and Findler, Robert Bruce and Gray, Kathryn E and Krishnamurthi, Shriram and Proulx, Viera K}} 

@misc{tung_2021, title={Visual studio code: How Microsoft's 'any OS, any programming language, any software' plan is paying off}, url={https://www.zdnet.com/article/visual-studio-code-how-microsofts-any-os-any-programming-language-any-software-plan-is-paying-off}, journal={ZDNet}, publisher={ZDNet}, author={Tung, Liam}, year={2021}, month={Feb}} 

@article{golog,
author = {Binder, David and Jabs, Julian and Skupin, Ingo and Ostermann, Klaus},
title = {Decomposition Diversity with Symmetric Data and Codata},
year = {2019},
issue_date = {January 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {POPL},
url = {https://doi.org/10.1145/3371098},
doi = {10.1145/3371098},
abstract = {The expression problem describes a fundamental trade-off in program design: Should a program's primary decomposition be determined by the way its domain objects are constructed ("functional" decomposition), or by the way they are destructed ("object-oriented" decomposition)? We argue that programming languages should not force one of these decompositions on the programmer; rather, a programming language should support both ways of decomposing a program in a symmetric way, with an easy translation between these decompositions. However, current programming languages are usually not symmetric and hence make it unnecessarily hard to switch the decomposition.  We propose a language that is symmetric in this regard and allows a fully automatic translation between "functional" and "object-oriented" decomposition. We present a language with algebraic data types and pattern matching for "functional" decomposition and codata types and copattern matching for "object-oriented" decomposition, together with a bijective translation that turns a data type into a codata type ("destructorization") or vice versa ("constructorization"). We present the first symmetric programming language with support for local (co)pattern matching, which includes local anonymous function or object definitions, that allows an automatic translation as described above. We also present the first mechanical formalization of such a language and prove i) that the type system is sound, that the translations between data and codata types are ii) type-preserving, iii) behavior-preserving and iv) inverses of each other. We also extract a mechanically verified implementation from our formalization and have implemented an IDE with direct support for these translations.},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {30},
numpages = {28},
keywords = {Refunctionalization, Types, Codata, Defunctionalization}
}

@Unpublished{phil,
  author = 	 {Philip Wadler},
  title = 	 {The {E}xpression {P}roblem},
  note = 	 {Note to Java Genericity mailing list},
  OPTkey = 	 {},
  month = 	 {Nov.},
  year = 	 {1998},
  OPTannote = 	 {}
}

@inproceedings{inproceedings,
author = {Cook, William},
year = {1991},
month = {01},
pages = {},
title = {Object-Oriented Programming Versus Abstract Data Types},
isbn = {978-3-540-53931-5},
doi = {10.1007/BFb0019443}
}


@inproceedings{kris,
author = {Krishnamurthi, Shriram and Felleisen, Matthias and Friedman, Daniel P.},
title = {Synthesizing Object-Oriented and Functional Design to Promote Re-Use},
year = {1998},
isbn = {3540647376},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
booktitle = {Proceedings of the 12th European Conference on Object-Oriented Programming},
pages = {91–113},
numpages = {23},
series = {ECCOP '98}
}

@book{okasaki1999purely,
  title={Purely functional data structures},
  author={Okasaki, Chris},
  year={1999},
  publisher={Cambridge University Press}
}