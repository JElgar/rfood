%% Real stuff
\newcommand{\kw}[1]{\texttt{#1} \;}
\newcommand{\kwinterface}{\kw{interface}}
\newcommand{\kwextends}{\kw{extends}}
\newcommand{\kwdata}{\kw{data}}
\newcommand{\kwmatch}{\kw{match}}
\newcommand{\kwclass}{\kw{class}}
\newcommand{\kwimplements}{\kw{impl}}
\newcommand{\kwif}{\kw{if}}
\newcommand{\kwelse}{\;\kw{else}}
\newcommand{\kwself}{\kw{Self}}
\newcommand{\kwfresh}{\kw{fresh}}

\newcommand{\generator}[1]{\textsc{Gen}(#1)}
\newcommand{\constructor}[1]{\textsc{Ctr}(#1)}
\newcommand{\destructor}[1]{\textsc{Dst}(#1)}
\newcommand{\consumer}[1]{\textsc{Csm}(#1)}
\newcommand{\gdefinition}[2]{\textsc{Def}(#1, #2)}

\newcommand{\genn}{G}
\newcommand{\ctrn}{C}
\newcommand{\dtn}{D}
\newcommand{\itn}{I}

\newcommand{\dt}{\textsc{Dt}}
\newcommand{\ite}{\textsc{It}}
\newcommand{\fn}{\textsc{Fn}}

\newcommand{\fresh}[1]{#1 \; \kwfresh}

\newcommand{\fntype}[2]{#1 \rightarrow #2}

\newcommand{\fnArg}[2]{#1:\; #2}
\newcommand{\fnArgs}[2]{\overline{#1:\; #2}}
\newcommand{\fnDstr}[3]{\kwdef \ f(#1, \;\overline{#2}): #3}
\newcommand{\fnDec}[3]{\kwdef f(#1): #2 = #3}
\newcommand{\block}[1]{\{ {#1} \}}
\newcommand{\blockO}[1]{\block{\overline{{#1}}}}
\newcommand{\ctr}[2]{#1(#2) \;}
\newcommand{\ctrPat}[2]{#1::#2}
\newcommand{\ctrCall}[3]{\ctrPat{#1}{#2}(\overline{#3}) \;}
\newcommand{\methodcall}[2]{#1.f(#2)}
\newcommand{\fncall}[1]{f(#1)}

% \newcommand{\class}[5]{\kwclass \; {#1} (\overline{{#2} : {#3}}) \; \kwimplements \; {#4} \; \blockO{#5}}
\newcommand{\class}[5]{\kwclass \; {#1} (\overline{{#2} : {#3}}) \; \kwimplements \; {#4} \; \block{{#5}}}

% stage 2 trans
\newcommand{\gdctx}{\Delta; \Gamma}
\newcommand{\transtwo}[4]{\gdctx \vdash_{#1} #2 \Rightarrow #3 \leadsto #4}
\newcommand{\transtwoNT}[3]{\Delta \vdash_{#1} #2 \leadsto #3}
\newcommand{\transtwoNTB}[3]{\Delta \vdash_{#1} #2 \leadsto \\ #3}

\newcommand{\transTypeExpr}[3]{\gdctx \vdash_{t} e \Rightarrow #1 \leadsto #2e \leftarrow #3}
\newcommand{\transType}[3]{#2 \overset{#1}{\leadsto} #3}

\newcommand{\datatype}[2]{\kwdata #1 \blockO{#2}}
\newcommand{\interface}[2]{\kwinterface #1 \; \blockO{#2}}

\newcommand{\macro}[2]{#1!(#2)}

\newcommand{\ifexpr}[2]{\kwif (#1) \overline{#2}}
\newcommand{\ifelseexpr}[3]{\ifexpr{#1}{#2} \kwelse \overline{#3}}
\newcommand{\blockexpr}[1]{\blockO{#1}}
\newcommand{\eqexpr}[2]{#1 == #2}
\newcommand{\macroexpr}[2]{\macro{#1}{\overline{#2}}}

\newcommand{\matchcase}[2]{\kwcase {#1} \Rightarrow \overline{#2}}
\newcommand{\matchcaseNO}[2]{\kwcase {#1} \Rightarrow {#2}}
\newcommand{\matchexpr}[3]{\kwmatch #1 =  \overline{\matchcase{#2}{#3}}}
\newcommand{\csmcase}[6]{\fnDstr{#1}{#2}{#3} = \matchexpr{\&#4} {#5} {#6}}

% \newcommand{\csmcase}[5]{\fnDstr{#1}{#2}{T'} = \matchexpr{#3} {#4} {#5}}

% \newcommand{\transSigmaCtx}[5]{\Delta; \Gamma {#1} \vdash^{#2} {#3} {#4} \leadsto {#5} \Rightarrow {#2}}
\newcommand{\transSigmaCtx}[6]{\Delta; \Gamma {#1} \vdash_{#6} {#3} {#4} \leadsto {#5} \leftarrow {#2}}
\newcommand{\transSigma}[3]{\transSigmaCtx{} {#1} {#2} {} {#3} {}}
\newcommand{\transSigmaType}[3]{\transSigmaCtx{} {#1} {#2} {} {#3} {t}}
\newcommand{\transSigmaInner}[3]{\transSigmaCtx{} {#1} {#2} {} {#3} {i}}
\newcommand{\transSigmaT}[4]{\transSigmaCtx{} {#1} {#2} {\Rightarrow #3} {#4} {}}
\newcommand{\transSigmaTInner}[4]{\transSigmaCtx{} {#1} {#2} {\Rightarrow #3} {#4} {i}}

\newcommand{\transThree}[3]{\Delta; \Gamma \vdash #1 \leadsto #2 \Rightarrow #3}
\newcommand{\transThreeStmt}[2]{\Delta; \Gamma \vdash #1 \leadsto #2}
\newcommand{\transThreeStmtB}[2]{\Delta; \Gamma \vdash #1 \leadsto \\ #2}


\newcommand{\typeInf}[3]{\Delta; \Gamma #1 \vdash #2 : #3}

% \newcommand{\binderspacing}{\,}
% \newcommand\keyword[1]{\mbox{\lstinline@#1@}}
\newcommand{\hast}{\!:\!}
\newcommand{\app}[2]{#1 \; #2}
\newcommand{\tapp}[2]{#1 \; @ #2}
\newcommand{\mergeop}{\; ,, \;}
\newcommand{\lam}[3]{\lambda (#1 \hast #2).\binderspacing #3}
\newcommand{\blam}[2]{\Lambda #1.\binderspacing #2}
\newcommand{\proj}[2]{{\code{proj}}_{#1} #2}
% \renewcommand{\for}[2]{\forall #1. \binderspacing #2}
\newcommand{\reccon}[2]{\{ #1=#2 \}}
\newcommand{\recty}[2]{\{ #1 \hast #2 \}}
\newcommand{\letexpr}[3]{\kwlet \; #1 = #2 \; \kwin \; #3}
\newcommand{\context}[2]{#1 \; {\vdash} \; #2}

% \newcommand{\eval}[2]{#1 \longrightarrow #2}
\newcommand{\eval}[2]{#1 \longrightarrow #2}
\newcommand{\fnsig}[2]{#1 \rightarrow #2}


\newcommand{\attrs}{\textsc{Attr}}
\newcommand{\sig}{\textsc{Sig}}
\newcommand{\defs}{\textsc{Def}}
\newcommand{\dtrBody}{\textsc{dtrBody}}
\newcommand{\csmBody}{\textsc{csmBody}}
\newcommand{\dtrType}{\textsc{dtrSig}}
\newcommand{\body}{\textsc{body}}
\newcommand{\fun}[2]{\dec{#1} = #2}
% \newcommand{\data}{\kw{data}\; C \{ \overline{P}\}}
% \newcommand{\case}{\kwcase\; C(\overline{x: T})}
\newcommand{\inter}[2]{\kwabstract \; \kwclass \; #1 \{ \overline{#2} \}}
\newcommand{\new}[2]{\kwnew \; #1(#2)}
\newcommand{\newSeq}[2]{\new #1{\overline{#2}}}


\newcommand{\kwinterface}{\kw{interface}}
\newcommand{\kwextends}{\kw{extends}}
\newcommand{\kwimplements}{\kw{implements}}
\newcommand{\kwtrait}{\kw{trait}}
\newcommand{\kwabstract}{\kw{abstract}}
\newcommand{\kwclass}{\kw{class}}
\newcommand{\kwcase}{\kw{case}}
\newcommand{\kwdef}{\kw{def}}
\newcommand{\kwsuper}{\kw{super}}
\newcommand{\kwthis}{\kw{this}}
\newcommand{\kwmatch}{\kw{match}}
\newcommand{\kwoverride}{\kw{override}}

\newcommand{\kwobj}{\kw{obj}}
\newcommand{\obj}[1]{C({\overline{#1}})}
\newcommand{\kwnew}{\kw{new}}
\newcommand{\kwarr}{\kw{=>}}
\newcommand{\kwint}{\kw{Int}}

\newcommand{\inbracket}[1]{\llbracket#1\rrbracket}
\newcommand{\dtr}[1]{\textsc{Dtr}(#1)}
\newcommand{\destr}[2]{\kwdef \ f(\kwself:#1)(\overline{#2 : Ts}): T}
\newcommand{\consumer}[1]{\textsc{Csm}(#1)}
\newcommand{\case}[2]{\kwcase\ {#1} \Rightarrow {#2}}
\newcommand{\csm}[3]{\kwdef \ f(#1, \overline{#2}): #3}
\newcommand{\csmcase}[4]{\csm {#1} {#2} {#3} = \overline{\case P{#4}}}
\newcommand{\dec}[2]{\kwdef \ f(\overline{#1}): #2}
\newcommand{\decD}[3]{\kwdef \ f(#1, \overline{#2}): #3}
\newcommand{\generator}[1]{\textsc{Gen}(#1)}
\newcommand{\toCase}[2]{\textsc{ToCase}(#1,#2)}
\newcommand{\ctrs}[1]{\textsc{Ctr}(#1)}
\newcommand{\dtrToCsm}[2]{\Delta;\Gamma \vdash_D #1 \leadsto #2}
\newcommand{\dtrToCsmCtx}[4]{\Delta;\Gamma, #1 : #2 \vdash_D #3 \leadsto #4}
\newcommand{\dtrToCase}[2]{\Delta;\Gamma \vdash_{f} {#1} \leadsto {#2}}
\newcommand{\csmToDtr}[2]{\Delta;\Gamma \vdash_C #1 \leadsto #2}
\newcommand{\csmSig}{\textsf{csm2dtrsig}}
\newcommand{\map}[3]{\langle #1 \; | \; #2 \leftarrow #3 \rangle}

\newcommand{\transCtx}[5]{\Delta;\Gamma, #1 \vdash^{#2} #3 \Rightarrow #4 \leadsto #5 \Rightarrow #2}
% \newcommand{\transTypeExpr}[2]{\Delta;\Gamma \vdash^{\sigma} e \Rightarrow #1T \leadsto #2 e \Rightarrow \sigma}
% \newcommand{\transTypeExprE}[2]{\Delta;\Gamma \vdash^{\sigma} #1 \leadsto #2 \Rightarrow \sigma}
\newcommand{\transTypeVal}[2]{\vdash_{#1} #2 \quad \text{\textbf{val}}}
\newcommand{\oldtrans}[3]{\Delta; \Gamma \vdash #1 \Rightarrow #2 \leadsto #3}
\newcommand{\trans}[4]{\Delta; \Gamma \vdash #1 \Rightarrow #2 \leadsto #3 \Rightarrow #4}
% \newcommand{\transSigma}[4]{\transSigmaCtx{} {#1} {#2} {#3} {#4}}
% \newcommand{\transSigmaCtx}[5]{\Delta; \Gamma #1 \vdash^{#2} #3 \Rightarrow #4 \leadsto #5 \Rightarrow #2}
\newcommand{\transGeneric}[4]{#1 \vdash #2 \Rightarrow #3 \leadsto #4}
\newcommand{\aliasCtx}{\Delta}
\newcommand{\toplike}[1]{\rceil #1 \lceil}
\newcommand{\subtype}[2]{#1 <: #2}
\newcommand{\Tau}{\mathrm{T}}
\newcommand{\all}[3]{\forall(#1*#2).#3}
\newcommand{\pr}[1]{\langle #1 \rangle}
\newcommand{\tid}{\kw{id}}
\newcommand{\ttop}{\kw{top}}
\newcommand{\tbot}{\kw{bot}}
\newcommand{\tdist}{\kw{dist}}
\newcommand{\returntype}{\textsc{returntype}}
\newcommand{\distinguish}{\textsc{distinguish}\xspace}
\newcommand{\sortCtx}{\Sigma}
\newcommand{\desugarType}[4]{\sortCtx \vdash_{#1}^{#2} #3 \Rightarrow #4}
\newcommand{\desugarTypeCtx}[5]{#1 \vdash_{#2}^{#3} #4 \Rightarrow #5}
% \newcommand{\ctrs}{\textsc{fields}}
\newcommand{\ctype}{\textsc{fieldType}}
\newcommand{\forward}{\textasciicircum\xspace}
\newcommand{\exclu}{\backslash}

\newcommand{\selDtr}{
\inferrule[Sel2App]
{ \trans {e_1} D {e_1'} \\ f \in \dtr{D} \\ \dtrType(f,D) = \overline{T} \rightarrow T\\ \overline{\trans {e_2} T {e_2'}}}
{ \trans{e_1.f(\overline{e_2})}{T}{f(e_1')(\overline{e_2'})}}
}
\newcommand{\appCsm}{
\inferrule[App2Sel]
{ \trans {e_1} D {e_1'} \\ f \in \consumer{D} \\ \sig(f) = D \rightarrow \overline{T} \rightarrow T \in \Gamma \\ \overline{\trans {e_2} T {e_2'}}}
{ \trans{f(e_1)(\overline{e_2})}{T}{e_1'.f(\overline{e_2'})}}
}
\newcommand{\appCtr}{
\inferrule[Obj2New]
{ \sig(C) = \overline{T} \rightarrow D \\ C \in \ctrs{D} \\ \overline{\trans e T e'}}
{ \trans{C(\overline{e})}{D}{\new C {e'}}}
}
\newcommand{\newGen}{
\inferrule[New2Obj]
{  \sig(C) = \overline{T} \rightarrow D \\ C \in \generator{D} \\ \overline{\trans e T e'}} %\\ {\trans t {\overline{T} \arrow T} {t'}} }
{ \trans{\newSeq C e}{D}{C(\overline{e'})}}
}

\newcommand{\eCongr}{
\inferrule[E-Congr]
{ \eval {e_1} {e_2}}
{ \eval{E[e_1]}{E[e_2]}}
}

% \inferrule[E-Var]
% { \overline{\eval e v}}
% { \eval{\new C e} obj(C,\overline{v})}

\newcommand{\enew}{
\inferrule[E-New]
{ }
{ \eval{\newSeq{C}{v}} {obj(C,\overline{v})}}
}

\newcommand{\ectr}{
\inferrule[E-Ctr]
{ }
{ \eval{C(\overline{v})}{obj(C,\overline{v})}}
}

% \newcommand{\edtr}{
% \inferrule[E-Dtr]
% { \eval{e_1}{obj(C,\overline{v_1})} \\ \overline{\eval{e_2}{v_2}} \\ \dtrBody(f,C) = (\overline{y},\overline{x},e) \\ \eval {[\kwthis \mapsto obj(C,\overline{v_1}),\overline{y} \mapsto \overline{v_1}, \overline{x} \mapsto \overline{v_2} ]e} v}
% { \eval{e_1.f(\overline{e_2})}{v} }
% }

\newcommand{\edtrInvk}{
\inferrule[E-Dtr]
{ \dtrBody(f,C) = (\overline{y},\overline{x},e)}
{ \eval{obj(C,\overline{v_1}).f(\overline{v_2})}{[\kwthis \mapsto obj(C,\overline{v_1}),\overline{y} \mapsto \overline{v_1}, \overline{x} \mapsto \overline{v_2} ]e}} 
}

\newcommand{\ecsmInvk}{
\inferrule[E-Csm]
{\csmBody(f,C) = (\overline{y},\overline{x},e)}
{ \eval {f(obj(C,\overline{v_1}))(\overline{v_2})} {[\kwself \mapsto obj(C,\overline{v_1}),\overline{y} \mapsto \overline{v_1}, \overline{x} \mapsto \overline{v_2}]e}}
}
\newcommand{\edtrRecv}{
\inferrule[E-Dtr-Recv]
{ \eval{e_1}{e_1'} }
{ \eval{e_1.f(\overline{e})}{e_1'.f(\overline{e})} }
}

\newcommand{\edtrArg}{
\inferrule[E-Dtr-Arg]
{ \eval{e_i}{e_i'} }
{ \eval{v_1.f(\overline{v},e_i, \overline{e})}{v_1.f(\overline{v},e_i,'\overline{e})} }
}

\newcommand{\ecsmDt}{
\inferrule[E-Csm-Dt]
{ \eval {e_1} {e_1'} }
{ \eval {f(e_1')(\overline{e_2})}{f(e_1')(\overline{e_2})}}
}

\newcommand{\ecsmArg}{
\inferrule[E-Csm-Arg]
{ \eval {e_i} {e_i'} }
{ \eval {f(v_1)(\overline{v},e_i,\overline{e})} {f(v_1)(\overline{v},e_i,\overline{e})}}
}
\newcommand{\efun}{
\inferrule[E-Fun]
{ \overline{\eval e v} \\ \body(f) = (\overline{x},e) \\ \eval {[\overline{x} \mapsto \overline{v}]e} v}
{ \eval {f(\overline{e})} v}
}

\newcommand{\dtrGen}{
\inferrule[DtrGen]
{ \defs(C) = \classf C y T D {\overline{Fun}} \\ \fun x {e} \in \overline{Fun} }
{ \dtrBody(f,C) = (\overline{y},\overline{x},e)}
}

\newcommand{\dtrIt}{
\inferrule[DtrIt]
{ \defs(C) = \classf C y T D {\overline{Fun}} \\ \defs(D) = \interface D {Dtr} \\ \fun x e \in \overline{Dtr}}
{ \dtrBody(f,C) = (\varnothing,\overline{x},e)}
}

\newcommand{\csmCtr}{
\inferrule[CsmCtr]
{ \defs(f) = \csmcase e \\ \case {C(\overline{y})}{e}  \in \overline{\case P e}}
{ \csmBody(f,C) = (\overline{y},\overline{x},e) }
}

\newcommand{\csmDt}{
\inferrule[CsmDt]
{ \defs(f) = \csmcase e \\ \case {\_}{e}  \in \overline{\case P e}}
{ \csmBody(f,C) = (\varnothing,\overline{x},e) }
}
